<!DOCTYPE html>
<html lang="en" color-mode="light" sound-mode="sound">
  <head>
    <meta charset="utf-8" />

    <title>Kai Chevannes</title>
    <meta name="description" content="Portfolio" />

    <link rel="icon" href="/favicon.ico" type="image/x-icon" />

    <link rel="stylesheet" href="/css/global.css" />
    <link rel="stylesheet" href="/css/utilities.css" />
    <link rel="stylesheet" href="/css/header.css" />
    <link rel="stylesheet" href="/css/styles.css" />
    <link rel="stylesheet" href="/css/project.css" />

    <script>
      if (
        localStorage.getItem("color-mode") === "dark" ||
        (window.matchMedia("(prefers-color-scheme: dark)").matches &&
          !localStorage.getItem("color-mode"))
      ) {
        document.documentElement.setAttribute("color-mode", "dark");
      }
      if (localStorage.getItem("sound-mode") === "muted") {
        document.documentElement.setAttribute("sound-mode", "muted");
      }
      document.documentElement.setAttribute("playing-mode", "playing");
    </script>
  </head>

  <body>
    <div class="max-width-wrapper">
      <header class="header">
        <div class="header__frosted-glass"></div>
        <h1 class="header__title">
          <a class="header__title-anchor" href="/">
            kai chevannes<span class="accent">.</span>
          </a>
        </h1>
        <div class="header__spacer">
          <div
            class="header__lightbulb slide-in"
            style="
              --offset: -80px;
              --duration: 1300ms;
              --ease-function: var(--spring-easing);
            "
          >
            <div class="header__lightbulb-cord"></div>
            <!-- Light mode lightbulb inner -->
            <svg
              class="header__lightbulb-inner light-mode-only"
              style="color: var(--color-highlight)"
            >
              <use href="/assets/svgs/lightbulb-inner.svg#lightbulb-inner" />
            </svg>
            <!-- Dark mode lightbulb inner -->
            <svg
              class="header__lightbulb-inner dark-mode-only"
              style="color: transparent"
            >
              <use href="/assets/svgs/lightbulb-inner.svg#lightbulb-inner" />
            </svg>
            <svg class="header__lightbulb-outer">
              <use href="/assets/svgs/lightbulb.svg#lightbulb" />
            </svg>
          </div>
        </div>
        <nav class="header__nav">
          <a href="/#about" class="header__nav-link">about</a>
          <a href="/#projects" class="header__nav-link">projects</a>
          <a href="/#contact" class="header__nav-link">contact</a>
        </nav>
        <div class="header__spacer"></div>
        <div class="header__buttons">
          <!-- Sound button -->
          <button
            class="header__button slide-in sound-on-only"
            onclick="setSoundMode('muted');"
          >
            <svg class="header__icon">
              <use href="/assets/svgs/volume-2.svg#volume-2" />
            </svg>
            sound
          </button>

          <!-- Muted button -->
          <button
            class="header__button slide-in sound-muted-only"
            onclick="setSoundMode('sound');"
          >
            <svg class="header__icon">
              <use href="/assets/svgs/volume-x.svg#volume-x" />
            </svg>
            muted
          </button>

          <!-- Light mode button -->
          <audio
            id="sound-lightoff"
            src="/assets/sounds/lightoff.mp3"
            preload="auto"
          ></audio>
          <button
            class="header__button slide-in light-mode-only"
            style="--delay: 300ms"
            onclick="setColorMode('dark'); playLightOff();"
          >
            <svg class="header__icon">
              <use href="/assets/svgs/sun.svg#sun" />
            </svg>
            light
          </button>

          <!-- Dark mode button -->
          <audio
            id="sound-lighton"
            src="/assets/sounds/lighton.mp3"
            preload="auto"
          ></audio>
          <button
            class="header__button slide-in dark-mode-only"
            style="--delay: 300ms"
            onclick="setColorMode('light'); playLightOn();"
          >
            <svg class="header__icon">
              <use href="/assets/svgs/moon.svg#moon" />
            </svg>
            dark
          </button>
        </div>
        <button
          class="header__button header__button--mobile slide-in"
          onclick="openMobileDialog()"
        >
          <svg class="header__icon header__icon--mobile">
            <use href="/assets/svgs/menu.svg#menu" />
          </svg>
        </button>
        <dialog id="mobile-dialog" class="header__mobile-dialog">
          <nav class="header__mobile-nav">
            <a href="/#about" class="header__nav-link header__nav-link--mobile"
              >about</a
            >
            <a
              href="/#projects"
              class="header__nav-link header__nav-link--mobile"
              >projects</a
            >
            <a
              href="/#contact"
              class="header__nav-link header__nav-link--mobile"
              >contact</a
            >
          </nav>
          <div class="header__mobile-buttons">
            <div>
              <!-- Light mode button -->
              <audio
                id="sound-lightoff"
                src="/assets/sounds/lightoff.mp3"
                preload="auto"
              ></audio>
              <button
                class="header__button header__button--mobile header__button--mobile-menu light-mode-only"
                onclick="setColorMode('dark'); playLightOff();"
              >
                <svg class="header__icon header__icon--mobile">
                  <use href="/assets/svgs/sun.svg#sun" />
                </svg>
                light
              </button>

              <!-- Dark mode button -->
              <audio
                id="sound-lighton"
                src="/assets/sounds/lighton.mp3"
                preload="auto"
              ></audio>
              <button
                class="header__button header__button--mobile header__button--mobile-menu dark-mode-only"
                onclick="setColorMode('light'); playLightOn();"
              >
                <svg class="header__icon header__icon--mobile">
                  <use href="/assets/svgs/moon.svg#moon" />
                </svg>
                dark
              </button>
            </div>
            <div>
              <!-- Sound button -->
              <button
                class="header__button header__button--mobile header__button--mobile-menu sound-on-only"
                onclick="setSoundMode('muted');"
              >
                <svg class="header__icon header__icon--mobile">
                  <use href="/assets/svgs/volume-2.svg#volume-2" />
                </svg>
                sound
              </button>

              <!-- Muted button -->
              <button
                class="header__button header__button--mobile header__button--mobile-menu sound-muted-only"
                onclick="setSoundMode('sound');"
              >
                <svg class="header__icon header__icon--mobile">
                  <use href="/assets/svgs/volume-x.svg#volume-x" />
                </svg>
                muted
              </button>
            </div>
          </div>
          <button
            class="header__button header__button--mobile header__button--close"
            onclick="closeMobileDialog()"
          >
            <svg class="header__icon header__icon--mobile">
              <use href="/assets/svgs/x.svg#x" />
            </svg>
          </button>
        </dialog>
      </header>
      <main class="project">
        <div class="project__page-title">
          <div class="project__details">
            <h1 class="project__title">Web Boids</h1>
            <p class="project__description">
              I ported my dissertation to multithreaded WASM, it's blazingly
              fast.
            </p>
          </div>
          <div>
            <h2 class="project__key-technologies">Key Technologies</h2>
            <div class="project__tech">
              <div class="project__tech-entry">
                <svg class="project__icon">
                  <use href="/assets/svgs/rust.svg#rust" />
                </svg>
                <p class="project__tech-text">Rust</p>
              </div>
              <div class="project__tech-entry">
                <svg class="project__icon">
                  <use href="/assets/svgs/webassembly.svg#webassembly" />
                </svg>
                <p class="project__tech-text">WebAssembly</p>
              </div>
              <div class="project__tech-entry">
                <svg class="project__icon">
                  <use href="/assets/svgs/vite.svg#vite" />
                </svg>
                <p class="project__tech-text">Vite</p>
              </div>
              <div class="project__tech-entry">
                <svg class="project__icon">
                  <use href="/assets/svgs/cssmodules.svg#cssmodules" />
                </svg>
                <p class="project__tech-text">CSS Modules</p>
              </div>
            </div>
          </div>
        </div>
        <div class="boids__wrapper">
          <div class="project__video-wrapper">
            <canvas
              id="boids-canvas"
              class="boids__canvas"
              width="1036"
              height="789"
            ></canvas>
            <button
              id="pause-button"
              class="project__video-button project__video-button--boids playing-only"
            >
              <svg class="project__video-button-icon">
                <use href="/assets/svgs/pause.svg#pause" />
              </svg>
            </button>
            <button
              id="play-button"
              class="project__video-button project__video-button--boids paused-only"
            >
              <svg class="project__video-button-icon">
                <use href="/assets/svgs/play.svg#play" />
              </svg>
            </button>
          </div>
          <div class="boids__tabs">
            <!-- Tab List -->
            <div role="tablist">
              <button
                role="tab"
                id="basic-tab"
                aria-controls="basic-controls"
                tabindex="0"
              >
                Basic
              </button>
            </div>

            <div>test</div>

            <div role="tablist">
              <button
                role="tab"
                id="advanced-tab"
                aria-controls="advanced-controls"
                tabindex="0"
              >
                Advanced
              </button>
            </div>
            <!-- Tab Panels -->
            <div
              role="tabpanel"
              id="basic-controls"
              class="boids__controls"
              aria-labelledby="basic-tab"
            >
              Content for tab one
            </div>
            <div
              role="tabpanel"
              id="advanced-controls"
              class="boids__controls"
              aria-labelledby="basic-tab"
            >
              Content for tab two
            </div>
          </div>
        </div>
        <section class="project__section">
          <h2 class="project__section-title">Preface</h2>
        </section>
        <svg class="project__icon--bleed">
          <use href="/assets/svgs/preface-squiggly.svg#preface-squiggly" />
        </svg>
        <section class="project__section">
          <h2 class="project__section-title">Summary</h2>
          <p class="project__section-content">
            I implemented an optimised version of the
            <a class="link" href="https://en.wikipedia.org/wiki/Boids">Boids</a>
            algorithm in Rust, improving performance with multithreading. This
            compiles to
            <span class="tooltip"
              >WebAssembly<span class="tooltiptext"
                >WebAssembly is a modern web standard that runs binary code
                compiled from LLVM supported languages like C, C++, and Rust at
                near-native speed in the browser.</span
              ></span
            >
            and runs as machine code in the browser.
          </p>
        </section>
        <section class="project__section">
          <h2 class="project__section-title">Purpose & Goal</h2>
          <p class="project__section-content">
            I wasn't satisfied with the performance of the Boids implementation
            I did for my University dissertation. Because it was written in
            Python without algorithmic optimisations, it could only run up to
            100 boids. I've also been interested in learning Rust, using
            <span class="tooltip"
              >Vite<span class="tooltiptext"
                >A frontend build tool and development server.</span
              ></span
            >, and writing library code. My acceptance criteria were:
          </p>
          <ol class="project__section-content">
            <li>
              <strong class="semibold">Implement</strong> an optimised Boids
              algorithm
            </li>
            <li>
              <strong class="semibold">Utilise</strong>
              <span class="tooltip"
                >Test Driven Development<span class="tooltiptext"
                  >A methodology of writing code where you first write failing
                  tests and then get them to pass.</span
                ></span
              >
            </li>
            <li>
              <strong class="semibold">Support</strong> multithreading natively
              and on the web
            </li>
            <li>
              <strong class="semibold">Verify</strong> optimisations improved
              performance
            </li>
          </ol>
          <p class="project__section-content">
            I started by reading
            <a class="link" href="https://doc.rust-lang.org/book/"
              >The Rust Programming Language</a
            >
            and completing <em>ThePrimeagen's</em>
            <a
              class="link"
              href="https://static.frontendmasters.com/ud/c/eddf8c40d0/aPVwjxMZsP/algorithms.pdf"
              >Algorithms Course</a
            >
          </p>
        </section>
        <section class="project__section">
          <h2 class="project__section-title">Spotlight</h2>
          <p class="project__section-content">
            Boids is a swarming algorithm modelled on the natural flocking
            patterns of birds. Each member of the swarm follows their own rules
            based on their surroundings, producing emergent behaviour. The Boids
            algorithm can produce many patterns of behaviour:
            <em>Birds</em> (see the <em>Basic</em> preset on the simulation
            above), <em>Fish</em> (see the <em>Maruyama</em> preset), and
            <em>UAVs</em> (see the <em>Zhang</em> preset). The Boids rules are
            as follows:
          </p>
          <ol class="project__section-content">
            <li>
              <strong class="semibold">Attraction</strong> — move towards nearby
              swarm members
            </li>
            <li>
              <strong class="semibold">Alignment</strong> — match direction with
              nearby swarm members
            </li>
            <li>
              <strong class="semibold">Separation</strong> — avoid crashing into
              nearby swarm members
            </li>
          </ol>
          <p class="project__section-content">
            The most intensive computation in the Boids algorithm is in
            determining neighbours. The naive algorithm is
            <span class="tooltip"
              ><strong class="semibold"
                >O(N<sup>2</sup>)<span class="tooltiptext"
                  >Big O notation tells us how much an algorithm slows down as
                  its input size increases.</span
                ></strong
              ></span
            >: for each <strong class="semibold">Nth</strong> swarm member we
            have to check our distance to all
            <strong class="semibold">N</strong> other swarm members. The tiled
            algorithm improves on this by splitting the grid into tiles as large
            as the Boids can see, and only checking Boids within adjacent tiles.
            Our <strong class="semibold">N</strong> Boids only have to check a
            fixed number of neighbours because each tile has a maximum capacity,
            determined by the swarms density. This means the algorithm is
            <strong class="semibold">O(N)</strong>.
          </p>
          <p class="project__section-content">
            The naive and the tiled algorithms can be improved by adding a
            multithreading strategy. I use the
            <a class="link" href="https://github.com/rayon-rs/rayon">rayon</a>
            Rust
            <span class="tooltip"
              >crate<span class="tooltiptext">A Rust package.</span></span
            >, which implements work stealing: each thread is given a queue of
            work, and once that queue is depleted it will start to steal chunks
            of work from other threads. We can fine-tune this strategy by
            adjusting the minimum number of tasks per chunk. If the minimum is
            low, we will spend more time stealing work than doing work, if it is
            too high then threads will start to sit idle.
          </p>
          <figure class="full-bleed">
            <img
              class="project__section-image"
              src="/assets/images/violin-1000.webp"
              alt="A violin graph with the average time in milliseconds on the x-axis and the minimum number of boids per thread on the y-axis. Values are shown as ranges of uncertainty."
            />
            <figcaption class="project__caption">
              Figure 1: Average time in milliseconds for 1,000 boids to complete
              100 timesteps over 100 samples, with 1–1,000 Boids per thread
              (multithreaded naive strategy). Both very low or very high Boids
              per thread give worse performance.
            </figcaption>
          </figure>
          <figure class="full-bleed">
            <img
              class="project__section-image"
              src="/assets/images/strategy-comparison.webp"
              alt="A line graph with four lines on it labelled as naive, naive_mt (multithreaded naive), tiled, tiled_mt (multithreaded tiled). The number of boids in the simulation is on the x-axis and the average time in seconds is on the y-axis."
            />
            <figcaption class="project__caption">
              Figure 2: Strategy comparison showing average time in milliseconds
              for 1–10,000 boids to complete 1,000 time steps over 100 samples,
              with 200 Boids per thread. The multithreaded strategies outperform
              the single-threaded strategies, and the tiled strategy outperforms
              the naive strategy.
            </figcaption>
          </figure>
        </section>
        <section class="project__section">
          <h2 class="project__section-title">Challenges</h2>
          <p class="project__section-contents">
            This was my ambitious project so far. WebAssembly is notorious
            challenging to set up, and I decided not only to try and use
            multithreaded
            <span class="tooltip"
              >WASM<span class="tooltiptext"
                ><strong>WebAssembly</strong></span
              ></span
            >
            — requiring me to use a nightly build of <em>Rust</em> with specific
            feature flags to even compile my project — but also bundle it into a
            Vite library using
            <span class="tooltip"
              >Rollup<span class="tooltiptext"
                >Vite's <strong>build tool</strong></span
              ></span
            >, then import it as an
            <span class="tooltip"
              >npm<span class="tooltiptext"
                ><strong>Node Package Manager</strong>. A public registry and
                command-line tool for publishing and installing JavaScript
                packages.</span
              ></span
            >
            package into a
            <span class="tooltip"
              >Next.js<span class="tooltiptext"
                >A full-stack <strong>meta-framework</strong> built on top of
                React.</span
              ></span
            >
            project that uses
            <span class="tooltip"
              >Webpack<span class="tooltiptext"
                >A legacy <strong>JavaScript bundler</strong>.</span
              ></span
            >, with next to no documentation to follow because nobody else is
            mad enough to try to import multithreaded WASM into a Next.js
            application.
          </p>
          <p class="project__section-content">
            I had a log of difficulty building my project into WebAssembly with
            threads. WASM doesn't natively support threads in the same way that
            operating systems do. Instead of CPU threads you use Service Workers
            spawned from JavaScript. This means you need to add a binding
            between Rust and JavaScript so that when you would usually create an
            operating system thread in Rust, you instead create a Service Worker
            in WebAssembly.
          </p>
          <p class="project__section-content">
            During development, every time I enabled WebAssembly multithreading
            my simulation started to run <em>more slowly</em>. I knew from my
            Rust benchmarks that the multithreaded code was faster natively, so
            I thought there must be some extra overhead in copying data between
            Service Workers in WASM. I ended up rearchitecting my code to remove
            all cloning of values but it was still slower. After confirming the
            code was running on different Service Workers I was at a loss.
            Later, when implementing the controls I found that when I increased
            the neighbour radii enough, multithreading actually
            <em>was</em> faster… I was just testing it on the wrong values.
          </p>
          <p class="project__section-content">
            I split my project into a WASM section, a Vite library, and a
            Next.js library consumer. I already had the link between the Vite
            library and Next.js working, so I thought that now I could just push
            the new package version to npm and see it work. I was
            <strong class="semibold">very</strong> wrong. Somewhere between
            <em>“Hello world”</em> and
            <em>“full multithreaded Boids implementation”</em> something broke,
            and I immediately regretted not continuously checking the build
            pipeline as I made changes.
          </p>
          <p class="project__section-content">
            I eventually found the magical Webpack encantations necessary for
            the single-threaded code to load, but the multithreaded code was
            crashing on worker instantiation. Several days of debugging later I
            came to the conclusion that the issue was likely to do with how
            Webpack handles dynamic imports, and dozens of patch versions later,
            I felt I was reaching diminishing returns and decided to move on.
          </p>
        </section>
        <section class="project__section">
          <h2 class="project__section-title">Lessons Learned</h2>
          <p class="project__section-content">
            I learned that Test Driven Development is very effective when
            writing library code. Writing the tests first left me confident that
            my simulation was correct, and when I wrote the visualiser, the
            simulation code worked first try. This is a stark constrast to my
            dissertation, where two months before submission I realised my
            simulation code has a massive bug in it:
            <strong class="semibold"
              >one of the Boids rules was being skipped over entirely due to a
              typo</strong
            >. The unoptimised algorithm meant that I didn't have enough time
            left to rerun the necessary simulations for my write-up, and I had
            to accept the failure. If I had used TDD, I would have caught this
            bug early.
          </p>
          <p class="project__section-content">
            Architecturally, I learned the cost of integrating different
            systems. Getting WebAssembly working in Rust isn't that difficult,
            writing a React library in Vite isn't that difficult, importing a
            React library into a Next.js project isn't that difficult. The
            astonishing difficulty comes from combining them, ending up with an
            enormous surface area for errors, many in external libraries.
          </p>
          <p class="project__section-content">
            In future projects, I will only adopt dependencies that reduce
            complexity. As programmers, our goal isn't to use the mightiest
            technologies, it's to deliver working software. If our mighty
            technologies prevent us from shipping code, they're worth nothing.
          </p>
        </section>
        <svg class="project__icon--bleed">
          <use
            href="/assets/svgs/postscript-squiggly.svg#postscript-squiggly"
          />
        </svg>
        <section class="project__section">
          <h2 class="project__section-title">Postscript</h2>
          <p class="project__section-content">
            NOTE: I pause and play the animation when it goes out of frame or
            switching tabs to reduce system load when not necessary.
          </p>

          <p></p>
        </section>
        <nav class="project__nav">
          <a class="project__nav-link" href="/gitops">← Gitops</a>
          <a
            class="project__nav-link project__nav-link--disabled"
            aria-disabled="true"
            tabindex="-1"
            >→</a
          >
        </nav>
      </main>
      <footer class="footer">
        <div class="footer__icons">
          <a href="https://wave.webaim.org/" class="footer__link">
            <svg class="footer__icon footer__icon--wave">
              <use href="/assets/svgs/wave.svg#wave" />
            </svg>
            Wave
          </a>
          <a href="https://www.deque.com/" class="footer__link">
            <svg class="footer__icon footer__icon--axe">
              <use href="/assets/svgs/axe.svg#axe" />
            </svg>
            Axe Deque
          </a>
          <a href="https://accessibilityinsights.io/" class="footer__link">
            <svg class="footer__icon">
              <use href="/assets/svgs/a11yinsights.svg#a11yinsights" />
            </svg>
            A11y Insights
          </a>
        </div>
        <div class="footer__icons">
          <a
            href="https://www.linkedin.com/in/kaichevannes/"
            class="footer__link"
          >
            <svg class="footer__icon">
              <use href="/assets/svgs/linkedin.svg#linkedin" />
            </svg>
            LinkedIn
          </a>
          <a href="https://github.com/kaichevannes" class="footer__link">
            <svg class="footer__icon footer__icon--github">
              <use href="/assets/svgs/github.svg#github" />
            </svg>
            GitHub
          </a>
        </div>
      </footer>
    </div>

    <script type="module">
      import init, * as wasm from "../assets/wasm/wasm_boids.js";

      const wasmInstance = await init();
      await wasm.initThreadPool(navigator.hardwareConcurrency);
      wasm.init_panic_hook();
      const universe = wasm.Builder.from_preset(wasm.Preset.Basic)
        .number_of_boids(500)
        .multithreaded(true)
        .number_of_boids_per_thread(200)
        .build();
      let playing = true;
      let showFps = true;

      let rafId = null;
      let tickTimeout = null;

      function tickLoop() {
        if (!playing) return;
        universe.tick();
        tickTimeout = setTimeout(tickLoop, 0);
      }

      function play() {
        playing = true;
        if (tickTimeout === null) {
          tickLoop();
        }
        if (rafId === null) {
          rafId = requestAnimationFrame(render);
        }
      }

      function pause() {
        playing = false;
        if (rafId !== null) {
          cancelAnimationFrame(rafId);
          rafId = null;
        }
        if (tickTimeout !== null) {
          clearTimeout(tickTimeout);
          tickTimeout = null;
        }
      }

      const playButton = document.getElementById("play-button");
      const pauseButton = document.getElementById("pause-button");
      const canvas = document.getElementById("boids-canvas");

      playButton.addEventListener("click", () => {
        play();
        document.documentElement.setAttribute("playing-mode", "playing");
      });

      pauseButton.addEventListener("click", () => {
        pause();
        document.documentElement.setAttribute("playing-mode", "paused");
      });

      let eventCausedPause = false;
      document.addEventListener("visibilitychange", () => {
        if (document.visibilityState === "visible") {
          if (eventCausedPause) {
            play();
            eventCausedPause = false;
          }
        } else {
          if (playing) {
            pause();
            eventCausedPause = true;
          }
        }
      });

      const observer = new IntersectionObserver(
        (entries) => {
          const entry = entries[0];

          if (entry.isIntersecting) {
            if (eventCausedPause) {
              play();
              eventCausedPause = false;
            }
          } else {
            if (playing) {
              pause();
              eventCausedPause = true;
            }
          }
        },
        {
          root: null,
          threshold: 0.3,
        },
      );
      observer.observe(canvas);

      let lastFrameTime = performance.now();

      function render(timestamp) {
        const FLOATS_PER_BOID = 6;
        const boidsPtr = universe.get_boids_pointer();
        const numBoids = universe.get_number_of_boids();
        const data = new Float32Array(
          wasmInstance.memory.buffer,
          boidsPtr,
          numBoids * FLOATS_PER_BOID,
        );
        let boids = [];
        for (let i = 0; i < numBoids; i++) {
          const offset = i * FLOATS_PER_BOID;

          const boid = {
            x: data[offset],
            y: data[offset + 1],
            vx: data[offset + 2],
            vy: data[offset + 3],
          };

          boids.push(boid);
        }

        const width = canvas.width;
        const height = canvas.height;
        const ctx = canvas.getContext("2d");

        if (!ctx) {
          return;
        }

        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = getComputedStyle(document.documentElement)
          .getPropertyValue("--color-background")
          .trim();
        ctx.fillRect(0, 0, width, height);
        ctx.fillStyle = getComputedStyle(document.documentElement)
          .getPropertyValue("--color-text")
          .trim();

        const universeSize = universe.get_size();
        const triangleSize = width / 100;
        boids.forEach((b) => {
          let x = (b.x / universeSize) * width;
          let y = (b.y / universeSize) * height;
          const angle = Math.atan2(b.vy, b.vx);

          ctx.setTransform(
            Math.cos(angle),
            Math.sin(angle),
            -Math.sin(angle),
            Math.cos(angle),
            x,
            y,
          );

          ctx.beginPath();
          ctx.moveTo(triangleSize, 0);
          ctx.lineTo(-triangleSize, triangleSize);
          ctx.lineTo(-triangleSize, -triangleSize);
          ctx.closePath();
          ctx.fill();
        });
        ctx.setTransform(1, 0, 0, 1, 0, 0);

        if (showFps) {
          const delta = timestamp - lastFrameTime;
          const instantaneous_fps = 1000 / delta;
          ctx.fillStyle = getComputedStyle(document.documentElement)
            .getPropertyValue("--color-primary")
            .trim();
          ctx.font = "20px monospace";
          ctx.fillText(`FPS: ${Math.trunc(instantaneous_fps)}`, width - 94, 20);
          lastFrameTime = performance.now();
        }

        if (playing) {
          rafId = requestAnimationFrame(render);
        }
      }

      play();
    </script>

    <script>
      document.querySelectorAll(".tooltip").forEach((timeout) => {
        let cleanupTimer = null;

        timeout.addEventListener("mouseenter", () => {
          clearTimeout(cleanupTimer);

          const text = timeout.querySelector(".tooltiptext");
          if (!text) return;

          const triggerRect = timeout.getBoundingClientRect();
          const tooltipWidth = text.offsetWidth; // works since visibility:hidden keeps it in layout
          const pad = 8;

          const naturalLeft =
            triggerRect.left + triggerRect.width / 2 - tooltipWidth / 2;
          const naturalRight = naturalLeft + tooltipWidth;

          let shift = 0;
          if (naturalLeft < pad) {
            shift = pad - naturalLeft;
          } else if (naturalRight > window.innerWidth - pad) {
            shift = window.innerWidth - pad - naturalRight;
          }

          timeout.style.setProperty(
            "--tooltip-shift",
            `${Math.round(shift)}px`,
          );
        });

        timeout.addEventListener("mouseleave", () => {
          cleanupTimer = setTimeout(() => {
            timeout.style.removeProperty("--tooltip-shift");
          }, 600);
        });
      });

      const mobileDialog = document.querySelector("#mobile-dialog");

      mobileDialog.addEventListener("click", (e) => {
        if (e.target === mobileDialog) {
          mobileDialog.close();
        }
      });

      function openMobileDialog() {
        mobileDialog.showModal();
      }

      function closeMobileDialog() {
        mobileDialog.close();
      }

      function setColorMode(mode) {
        document.documentElement.setAttribute("color-mode", mode);
        localStorage.setItem("color-mode", mode);

        const lightButton = document.querySelector(
          ".header__button.light-mode-only",
        );
        const darkButton = document.querySelector(
          ".header__button.dark-mode-only",
        );

        lightButton.classList.remove("slide-in");
        darkButton.classList.remove("slide-in");
      }

      function setSoundMode(mode) {
        document.documentElement.setAttribute("sound-mode", mode);
        localStorage.setItem("sound-mode", mode);

        const soundButton = document.querySelector(
          ".header__button.sound-on-only",
        );
        const mutedButton = document.querySelector(
          ".header__button.sound-muted-only",
        );

        soundButton.classList.remove("slide-in");
        mutedButton.classList.remove("slide-in");
      }

      const lightOnAudio = document.getElementById("sound-lighton");
      function playLightOn() {
        if (document.documentElement.getAttribute("sound-mode") === "muted")
          return;

        lightOnAudio.currentTime = 0;
        lightOnAudio.play();
      }

      const lightOffAudio = document.getElementById("sound-lightoff");
      function playLightOff() {
        if (document.documentElement.getAttribute("sound-mode") === "muted")
          return;

        lightOffAudio.currentTime = 0;
        lightOffAudio.play();
      }
    </script>
  </body>
</html>
